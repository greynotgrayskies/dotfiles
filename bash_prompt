# Sets bash prompt
# 
# Adapted from: 
# https://github.com/albert12132/dotfiles/blob/master/bash-files/bash_prompt

# Bash provides an environment variable called `PROMPT_COMMAND`. The contents
# of this variable are executed as a regular Bash command just before Bash
# displays a prompt.
# http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x264.html
promptCommand() {
    # Needs to be done first, since otherwise we might lose the exit code.
    local EXIT_CODE=$?

    local EXIT_STATUS
    local GIT_PROMPT
    local WORK_DIRECTORY
    local PROMPT

    # Exit Status Display
    if [[ ${EXIT_CODE} != 0 ]]; then
        EXIT_STATUS="${DEFAULT}${RED}${BOLD}(exit status: ${EXIT_CODE})\n"
    fi

    # Git Display
    if $(isGitRepo); then
        local GIT_BRANCH=$(git branch 2> /dev/null | sed -n 's/^\* //p')
        GIT_PROMPT="${DEFAULT} "
        if [[ $(gitStatus) -eq 0 ]]; then
            GIT_PROMPT+="(${LIGHT_GREEN}${BOLD}"'$(gitBranch)'"${DEFAULT})"
        else
            GIT_PROMPT+="(${GOLD}${BOLD}"'$(gitBranch)'"${DEFAULT})"
        fi    
    fi

    WORK_DIRECTORY="${DEFAULT}${GOLD}\u@\h:${DEFAULT}\w"
    PROMPT="${DEFAULT}${LIGHT_GREEN}${BOLD}\$${DEFAULT} "

    export PS1="${EXIT_STATUS}${WORK_DIRECTORY}${GIT_PROMPT}\n${PROMPT}"

    # Clear any previous formatting
    echo -ne "\e[0m"
}

# Should be a triangle? May not appear correctly until the powerline font is
# actually properly installed.
# http://askubuntu.com/questions/283908/how-can-i-install-and-use-powerline-plugin
SEPARATOR="\uE0B0"

if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null
then
    # We have color support; assume it's compliant with Ecma-48
    # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
    # a case would tend to support setf rather than setaf.)
    color_prompt=yes
else
    color_prompt=
fi

isVirtualEnv() {
    if env | grep -q 'VIRTUAL_ENV='
    then
        echo '-'
    fi
}

isGitRepo() {
    git status &> /dev/null
}

gitBranch() {
    local branch=$(git branch 2> /dev/null | sed -n 's/^\* //p')
    if [ -n "$branch" ] ; then echo $branch ; fi
}

gitStatus() {
    local changes=$(git status --short 2> /dev/null | wc -l)
    echo $changes
}

# Outputs a message containing the exit code of a previous command if it
# resulted in a non-zero exit code
exitStatusPrompt() {
    EXIT_CODE=$?
    if [[ ${EXIT_CODE} != 0 ]]; then
        echo "${RED}(exit status: ${EXIT_CODE})\n"
    fi
}

# Fancy Terminal Colors (more than necessary)
# https://en.wikipedia.org/wiki/ANSI_escape_code
#
# Gnome Terminal apparently can support 24-bit colors, but requires to be
# linked against libvte >= 0.36, so it doesn't work in Ubuntu 14.04. Can't be
# bothered at the moment.
# http://askubuntu.com/questions/512525/how-to-enable-24bit-true-color-support-in-gnome-terminal

# Returns the ANSI control sequence 
rgb() {
    expr 16 + 36 \* $1 + 6 \* $2 + $3
}

# Returns the ANSI control sequence for a foreground color for an rgb value.
fgcolor() {
    echo "\e[38;5;$(rgb $1 $2 $3)m"
}
    
# Returns the ANSI control sequence for a background color for an rgb value.
bgcolor() {
    echo "\e[48;5;$(rgb $1 $2 $3)m"
}

if [ "$color_prompt" = yes ]; then
    # Control sequences need to be wrapped in '\[' and '\]', or else inputs
    # that exceed one line may wrap over incorrectly by overwriting the
    # characters at the beginning of the current line.

    # Fonts
    DEFAULT="\[\e[0m\]"
    BOLD="\[\e[1m\]"
    UNDER="\[\e[4m\]"
    INVERT="[\e[7m\]"

    # Font Colors
    GREY="\[$(fgcolor 2 2 2)\]"
    RED="\[$(fgcolor 5 0 0)\]"
    GOLD="$(fgcolor 5 3 0)"
    LIGHT_GREEN="\[$(fgcolor 0 5 0)\]"
    BROWN="\[$(fgcolor 3 2 0)\]"
fi

PROMPT_COMMAND=promptCommand

unset color_prompt force_color_prompt
